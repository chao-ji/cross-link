import re
import math
import glob
import pickle
import sys

from peptide import Peptide
from xlink import XLink
from match import Match
from mzxmlreader import MZXMLReader
from fastareader import FastaReader
from random import shuffle

def logit(coef, x):
	v = x
	x = [1]
	x.extend(v)
	val = 0

	for i in range(len(coef)):
		val += coef[i] * x[i]
	
	return float(1) / (1 + math.exp(-val))

def adjust_prior_marginal(prior_tr, model_output, marginal, iterations):
	posterior_tr = []
	for per_spec in model_output:
		posterior_tr.extend(per_spec)

	n = len(posterior_tr)
	prior = prior_tr
	posterior = [0.0] * n

	for i in range(iterations):
		for k in range(n):
			denominator = (float(prior) / prior_tr) * posterior_tr[k] + (float(1 - prior) / (1 - prior_tr)) * (1 - posterior_tr[k])
			try:
				posterior[k] = float(prior * posterior_tr[k]) / (prior_tr * denominator)
			except ZeroDivisionError:
				print 'denominator equals 0!'
		prior_prev = prior
		prior = 0.0
		for j in range(n):
			prior = prior + posterior[j] * marginal[j]
		prior = prior / sum(marginal)
		print 'iteration = %d, %.10f' % (i, prior)
		if i > 0 and abs(float(prior_prev - prior) / prior_prev) <= 0.01:
			print '%f' % abs(float(prior_prev - prior) / prior_prev)
			break

	new_model_output = []
	begin = 0

	for i in range(len(model_output)):
		end = begin + len(model_output[i])
		new_model_output.append(posterior[begin : end])
		begin = end

	return new_model_output

def get_marginal(p21, p11, p12, p22):
	alpha_T = []
	beta_T = []
	alpha_F =  []
	beta_F = []

	for i in range(len(p21)):
		for j in range(len(p21[i])):
			denominator = 1.0 - (p11[i][j] - p12[i][j]) * (p21[i][j] - p22[i][j])

			try:
				at = (p12[i][j] + p22[i][j] * (p11[i][j] - p12[i][j])) / denominator
			except ZeroDivisionError:
				print 'denominator equals 0!'

			try:
				bt = (p22[i][j] + p12[i][j] * (p21[i][j] - p22[i][j])) / denominator
			except ZeroDivisionError:
				print 'denominator equals 0!'

			af = 1.0 - at
			bf = 1.0 - bt
			alpha_T.append(at)
			beta_T.append(bt)
			alpha_F.append(af)
			beta_F.append(bf)

	return [alpha_T, beta_T, alpha_F, beta_F]

def get_matches_per_spec(mass, param, index, title):
	spec_dict = index.spec_dict
	unique_pep = index.unique_pep[0]
	prec_mass_pep_index_tuple = index.prec_mass_pep_index_tuple
	search_index = index.search_index
	x_residue = param['x_residue']

	index_list = search_index[title]
	spec = spec_dict[title]

	matches = []
	xls = []
	for i in index_list:
		index1 = prec_mass_pep_index_tuple[1][i]
		index2 = prec_mass_pep_index_tuple[2][i]
		
		pep1 = unique_pep[index1]
		pep2 = unique_pep[index2]

		pep_sorted = sorted([pep1, pep2], key = lambda x : x.seq)
		pep1 = pep_sorted[0]
		pep2 = pep_sorted[1]

		ch = spec_dict[title].ch

		mz = spec_dict[title].mz
		it = spec_dict[title].it

		k_pos1 = []
		k_pos2 = []
		if param['ntermxlink'] == True:
			if pep1.is_nterm == True:
				k_pos1.append(0)
			if pep2.is_nterm == True:
				k_pos2.append(0)

		pep_seq1 = pep1.seq
		k_pos1.extend(list(zip(*filter(lambda x : x[1] == x_residue, enumerate(pep_seq1[:-1])))[0]))
		pep_seq2 = pep2.seq
		k_pos2.extend(list(zip(*filter(lambda x : x[1] == x_residue, enumerate(pep_seq2[:-1])))[0]))

		for p1 in k_pos1:
			for p2 in k_pos2:
				pos = [p1, p2]
				xl = XLink(pep1, pep2, pos, ch, mass, param)
				xls.append(xl)
			
				match = Match(spec, xl, mass, param)
				match.match(mass)
				matches.append(match.get_match_info(index))

	return matches

def get_pep_from_pro(header, pro_seq, pattern_string, mass, param):
	missed_sites = param['missed_sites']
	min_len = param['min_length']
	max_len = param['max_length']
	mod_res = param['mod_res']
	pattern = re.compile(pattern_string)
	sites = [0]

	for i in range(len(pro_seq)):
		if i == len(pro_seq) - 1:
			sites.append(i + 1)
		elif (pro_seq[i] == 'K' or pro_seq[i] == 'R') and pro_seq[i + 1] != 'P':
			sites.append(i + 1)

	pep_seqs = []

	for i in range(len(sites)):
		if i < len(sites) - missed_sites - 1:
			for j in range(missed_sites + 1):
				pep_seq = pro_seq[sites[i] : sites[i + j + 1]]
				if len(pep_seq) >= min_len and len(pep_seq) <= max_len and pattern.match(pep_seq):
					pep_seqs.append(pep_seq)
		else:
			for j in range(i + 1, len(sites)):
				pep_seq = pro_seq[sites[i] : sites[j]]
				if len(pep_seq) >= min_len and len(pep_seq) <= max_len and pattern.match(pep_seq):
					pep_seqs.append(pep_seq)

	pep_seqs = list(set(pep_seqs))
	peps = []

	for pep_seq in pep_seqs:
		modif = dict(position=[], delta_mass=[])
		is_nterm = False
		if pep_seq == pro_seq[:len(pep_seq)]:
			is_nterm = True
		peps.append(Peptide(pep_seq, header, modif, mass, is_nterm))
		if len(mod_res) != 0:
			mod_mass = param['mod_mass']
			index = [i for i, ltr in enumerate(pep_seq) if ltr == mod_res]
			if len(index) != 0:
				pep_seq = list(pep_seq)
				for i in index:
					modif = dict(position=[], delta_mass=[])
					modif['position'].append(i)
					modif['delta_mass'].append(mod_mass)

					pep_seq[i] = pep_seq[i].lower()
				pep_seq = ''.join(pep_seq)
				peps.append(Peptide(pep_seq, header, modif, mass, is_nterm))

	return peps

def read_param(filename):
	param = dict(
		use_a_ion=True,
		verbose=False,
		ch_pre_xlink_ions=[1, 3],
		ch_post_xlink_ions=[2, 5],
		base_peak_int = 100.0,
		dynamic_range = 0.001,
		missed_sites = 2,
		min_length = 4,
		max_length = 51,
		mod_res = '',
		mod_mass = 0.0,
		linker_mass = 136.10005,
		ms1_tol = dict(measure='ppm', val=5),
		ms2_tol = dict(measure='da', val=0.01),
		min_mz = 200,
		max_mz = 2000,
		mode = 'conservative',
		x_residue = 'K',
		aa = 'ACDEFGHIKLMNPQRSTVWY',
		neutral_loss=dict(
			h2o_loss=dict(
				mass=-18.010565,
				aa=set('ACDEFGHIKLMNPQRSTVWY')),
			nh3_loss=dict(
				mass=-17.026549,
				aa=set('ACDEFGHIKLMNPQRSTVWY')),
			h2o_gain=dict(
				mass=18.010565,
				aa=set('ACDEFGHIKLMNPQRSTVWY'))),
		model_TT_TF = [0.0] * 17,
		model_TF_FF = [0.0] * 17,
		nTT = 169,
		nTF = 8568,
		nFF = 91242)
		
	mass = dict(
		A=71.037114,
		R=156.101111,
		N=114.042927,
		D=115.026943,
		C=103.009184,
		E=129.042593,
		Q=128.058578,
		G=57.021464,
		H=137.058912,
		I=113.084064,
		L=113.084064,
		K=128.094963,
		M=131.040485,
		F=147.068414,
		P=97.052764,
		S=87.032028,
		T=101.047678,
		W=186.079313,
		Y=163.063329,
		V=99.068414,
		Hatom=1.007825032,
		Oatom=15.99491462,
		neutron_mass = 1.008701,
		b_ion_res=1.0078246,
		a_ion_res=-26.9870904,
		y_ion_res=19.0183888,
		isotope_inc = [1.008701/4, 1.008701/3, 1.008701/2, 1.008701/1])

	f = open(filename)	
	lines = f.readlines()
	for l in lines:
		l = l[:-1]
		cols= l.split('\t')
		if len(l) == 0 or l[0] == '#' or len(cols) < 2:
			continue

		name = cols[0]
		val = cols[1]
		if name == 'database':
			param['database'] = val
		elif name == 'MS_data_directory':
			param['ms_data'] = val
		elif name == 'XLresidue':
			param['x_residue'] = val
		elif name == 'ms1tol_unit':
			param['ms1_tol']['measure'] = val
		elif name == 'ms1tol_val':
			param['ms1_tol']['val'] = int(val)
		elif name == 'ms2tol_unit':
			param['ms2_tol']['measure'] = val
		elif name == 'ms2tol_val':
			param['ms2_tol']['val'] = float(val)
		elif name == 'linker_mass':
			param['linker_mass'] = float(val)
		elif name == 'miss_cleave':
			param['missed_sites'] = int(val)
		elif name == 'include_a_ions':
			param['use_a_ion'] = True if val.lower() == 'true' else False 
		elif name == 'min_peplen':
			param['min_length'] = int(val)
		elif name == 'max_peplen':
			param['max_length'] = int(val)
		elif name == 'fix_mod_res':
			param['fix_mod_res'] = val
		elif name == 'fix_mod_mass':
			param['fix_mod_mass'] = float(val)
		elif name == 'var_mod_res':
			param['mod_res'] = val
		elif name == 'var_mod_mass':
			param['mod_mass'] = float(val)
		elif name == 'min_preXL_ions_ch':
			param['ch_pre_xlink_ions'][0] = int(val)
		elif name == 'max_preXL_ions_ch':
			param['ch_pre_xlink_ions'][1] = int(val)
		elif name == 'min_postXL_ions_ch':
			param['ch_post_xlink_ions'][0] = int(val)
		elif name == 'max_postXL_ions_ch':
			param['ch_post_xlink_ions'][1] = int(val)
		elif name == 'target_database':
			param['target_database'] = val
		elif name =='uniprot_database':
			param['uniprot_database'] = val
		elif name == 'max_iterations':
			param['max_iterations'] = int(val)
		elif name == 'annotate_spec':
			param['annotation'] = True if val.lower() == 'true' else False
		elif name == 'deisotope':
			param['deisotope'] = True if val.lower() == 'true' else False
		elif name == 'ndeisotope':
			param['ndeisotope'] = int(val)
		elif name == 'ntermxlink':
			param['ntermxlink'] = True if val.lower() == 'true' else False
		elif name == 'decoy_string':
			param['decoy_string'] = val
		elif len(name) >= 4 and name[:2] == 'CI':
			if len(name) == 4:
				s = int(name[2:])
				param['model_TT_TF'][s] = float(val)
			elif len(name) == 5:
				s = int(name[3:])
				param['model_TF_FF'][s] = float(val)
		elif name == 'nTT':
			param['nTT'] = int(val)
		elif name == 'nTF':
			param['nTF'] = int(val)
		elif name == 'nFF':
			param['nFF'] = int(val)

	param['pattern_string'] = '^[' + param['aa'] + ']*' + param['x_residue'] + '[' + param['aa'] + ']+$'
	param['prior_tr_TT_TF'] = float(param['nTT']) / (param['nTT'] + param['nTF'])
	param['prior_tr_TF_FF'] = float(param['nTF']) / (param['nTF'] + param['nFF'])

	f.close()
	if len(param['fix_mod_res']) > 0:
		mass[param['fix_mod_res']] += param['fix_mod_mass']

	return [param, mass]

def read_spec(directory, param, mass):
	files = glob.glob(directory + '*.mzXML')

	spec_dict = dict()
	total = []
	for filename in files:
		reader = MZXMLReader(filename)
		spec = reader.get_spec_list(mass, param)
		total.append(spec)

	ss = []
	for i in range(len(total)):
		ss.append(set())

		tmp = []
		for j in range(len(total[i])):
			if total[i][j].ret_time >= 0 and total[i][j].ret_time <= 110*60 and total[i][j].ch >= 2 and total[i][j].ch <= 7:
				tmp.append(total[i][j])

		tmp = sorted(tmp, key = lambda s : s.mol_weight)

		tolerance = 0.01
		lower_ratio = 0.3
		upper_ratio = 1 / float(lower_ratio)

		for j in range(len(tmp) - 1):
			MZ = []
			IT = []
			mz = tmp[j].mz
			it = tmp[j].it
			last_index = 0
			ik = 0
			jk = 0
			for ik in range(len(mz)):
				if last_index == 0:
					jk = 0
				else:
					jk = last_index
				while not (last_index > len(mz) - 1 or jk > len(mz) - 1 or ik > len(mz) - 1 or mz[jk] > mz[ik] + tolerance):
					if mz[jk] <= mz[ik] - tolerance:
						last_index = jk

					ratio = float(it[ik]) / float(it[jk])
					if abs(mz[ik] - mz[jk]) <= tolerance and ratio >= lower_ratio and ratio <= upper_ratio:
						MZ.append(mz[ik])
						IT.append(it[ik])
					jk = jk + 1	
			if len(MZ) >= 25:
				spec_dict[tmp[j].title] = tmp[j]
	return spec_dict

def get_tophits(index, result):
	model_TT_TF = index.param['model_TT_TF']
	model_TF_FF = index.param['model_TF_FF']
	prior_tr_TT_TF = index.param['prior_tr_TT_TF']
	prior_tr_TF_FF = index.param['prior_tr_TF_FF']
	max_iterations = index.param['max_iterations']

	p21 = []
	p11 = []
	p12 = []
	p22 = []

	for i in range(len(result)):
		print i

		p21.append([])
		p11.append([])
		p12.append([])
		p22.append([])

		for j in range(len(result[i][1])):

			feature = result[i][1][j][2]
			x = list(feature[0])
			x.extend(feature[1])
			x_flip = list(feature[1])
			x_flip.extend(feature[0])
			b = model_TT_TF

			p21[-1].append(logit(b, x))
			p11[-1].append(logit(b, x_flip))

			b = model_TF_FF

			p12[-1].append(logit(b, x))
			p22[-1].append(logit(b, x_flip))

	[alpha_T, beta_T, alpha_F, beta_F] = get_marginal(p21, p11, p12, p22)
	p21 = adjust_prior_marginal(prior_tr_TT_TF, p21, alpha_T, max_iterations)
	p11 = adjust_prior_marginal(prior_tr_TT_TF, p11, beta_T, max_iterations)
	p12 = adjust_prior_marginal(prior_tr_TF_FF, p12, beta_F, max_iterations)
	p22 = adjust_prior_marginal(prior_tr_TF_FF, p22, alpha_F, max_iterations)

	for i in range(len(result)):
		print i
		result[i] = list(result[i])

		for j in range(len(result[i][1])):

			pep1 = index.unique_pep[0][result[i][1][j][0][0]]
			pep2 = index.unique_pep[0][result[i][1][j][0][1]]

			ap21 = p21[i][j]
			ap11 = p11[i][j]
			ap12 = p12[i][j]
			ap22 = p22[i][j]

			denominator = 1 - (ap11 - ap12) * (ap21 - ap22)

			try:
				marginal_alaph_T = (ap12 + ap22 * (ap11 - ap12)) / denominator
			except ZeroDivisionError:
				print 'denominator equals 0!'

			try:
				marginal_beta_T = (ap22 + ap12 * (ap21 - ap22)) / denominator
			except ZeroDivisionError:
				print 'denominator equals 0!'

			prob1 = ap11 * marginal_beta_T
			prob2 = ap21 * marginal_alaph_T
			score = (prob1 + prob2) / float(2)

			info = {'alpha' : marginal_alaph_T, 'beta' : marginal_beta_T, 'prob' : [prob1, prob2], 'score' : score}

			result[i][1][j] = list(result[i][1][j])
			result[i][1][j].append(info)

	for r in result:
		r[1] = sorted(r[1], key = lambda x : x[3]['score'], reverse = True)

	result = sorted(result, key = lambda x : x[1][0][3]['score'], reverse = True)

	tophits = []

	for r in result:
		scan = r[0]
		pep = [index.unique_pep[0][r[1][0][0][0]].seq, index.unique_pep[0][r[1][0][0][1]].seq]
		pos = [int(r[1][0][1][0]), int(r[1][0][1][1])]
		pro = [index.unique_pep[0][r[1][0][0][0]].pro_id, index.unique_pep[0][r[1][0][0][1]].pro_id]
		ch = int(scan.split('.')[-1])
		score = r[1][0][3]['score']
		alpha = r[1][0][3]['alpha']
		beta = r[1][0][3]['beta']
		tophits.append([pep, pos, pro, ch, score, alpha, beta, scan])

	return tophits

def write_results(output_file, tophits):
	f = open(output_file, 'w')
	f.write('Rank\tPep_alpha\tPep_beta\tSite_alpha\tSite_beta\tPro_alpha\tPro_beta\tCharge\tpr(alpha=T,beta=T)\tpr(alpha=T)\tpr(beta=T)\tSpectrum\n')
	for i in range(len(tophits)):
		f.write('%d\t' % (i + 1))
		f.write('%s\t%s\t' % (tophits[i][0][0], tophits[i][0][1]))
		f.write('%d\t%d\t' % (tophits[i][1][0], tophits[i][1][1]))
		f.write('%s\t%s\t' % (','.join(tophits[i][2][0]), ','.join(tophits[i][2][1])))
		f.write('%d\t' % tophits[i][3])
		f.write('%E\t' % tophits[i][4])
		f.write('%E\t' % tophits[i][5])
		f.write('%E\t' % tophits[i][6])
		f.write('%s\n' % tophits[i][7])
	f.close()
